Cursor实现原理初探


概述
Cursor是最受欢迎的AI代码编辑器之一。最近http://newsletter.pragmaticengineer.com上发表了一篇和Cursor工程访谈的记录文章。该文章访谈了Cursor的开发者，并询问了很多Cursor的具体实现原理。这里对这篇文章的核心内容进行了总结。



Cursor的设计理念
我们需要拥有自己的编辑器，而不能‘仅仅’成为一个扩展，因为我们想要改变人们的编程方式。这意味着我们要么构建一个全新的 IDE，要么 fork 一个现有的编辑器。

我们的价值主张并非构建一个稳定的编辑器，而是改变开发者的编程方式，并以渐进的方式进行。

开发Cursor使用的技术栈
Backend（后端）
TypeScript ：大多数业务逻辑都以此编写。
Rust ：所有性能关键型组件都使用这种语言。下文讨论的 Orchestrator 就是一个例子。
Node API 到 Rust： 大多数业务逻辑使用 TypeScript，而性能密集型部分使用 Rust，因此有一个桥梁可以通过 Node.js 从 TypeScript 调用 Rust 代码。一个例子是调用索引逻辑（用 Rust 编写），它大量使用了这座桥梁。
单体式架构：后端服务主要是一个大型单体式架构，并作为一个整体进行部署。 这提醒我们，单体式架构对于早期创业公司来说非常有效，可以帮助团队快速发展。


Databases（数据库）
Turbopuffer ：一个用于存储加密文件和工作区 Merkle 树的多租户数据库，下文将详细介绍。团队之所以青睐该数据库，是因为其可扩展性，并且无需像以前那样处理数据库分片的复杂性 。我们将在下文的“工程挑战”中介绍相关挑战。
Pinecone ： 用于存储文档嵌入内容的向量数据库


Data streaming（流数据）：
Warpstream ：与 Apache Kafka 兼容的数据流服务
Tooling: 工具：
Datadog ：用于日志记录和监控。Sualeh 表示，他们是 Datadog 的重度用户，并且发现 Datadog 的开发者体验远胜于其他同类产品。
PagerDuty ：用于值班管理，与 Slack 集成
Slack ：内部通讯和聊天
Sentry ：错误监控
Amplitude: 分析
Stripe ：使用 Cursor 购买计划时的计费和付款。
WorkOS ： 登录 Cursor 时的身份验证，例如使用 GitHub 或 Google Workspace 登录
Vercel ：http://Cusor.com 网站托管的平台
Linear: 用于管理工作
大部分 CPU 基础设施在 AWS 上运行。他们还运营着数万块 NVIDIA H100 GPU。其中很大一部分 GPU 在 Azure 中运行。

Inference（推理）是 Cursor 迄今为止最大的 GPU 用例，这意味着生成下一个 token，可以是自动补全，也可以是完整的代码块。实际上，Azure GPU 仅用于推理，而不是其他与 LLM 相关的工作，例如微调和训练模型。

Cursor 使用 Terraform 来管理 GPU 和虚拟机（如 EC2 实例）等基础设施。

Cursor 自动补全的工作原理
为了了解构建 Cursor 的一些技术挑战，让我们看看第一次启动编辑器时会发生什么。




低延迟同步引擎：自动补全建议
打开项目或文件夹后，您很可能会直接编辑文件。这意味着 Cursor 需要生成自动补全建议，Cursor 团队称之为“tab建议”。 低延迟同步引擎驱动着“tab模型”。 它会生成灰色的建议，点击“Tab”键即可接受。这些建议需要快速生成，理想情况下不超过一秒。以下是幕后运作：





自动补全的工作原理：

当前上下文窗口（代码）的一小部分由客户端本地收集
代码已加密
加密的代码/上下文被发送到后端
后端解密代码/上下文
使用 Cursor 内部的 LLM 模型生成建议
补全建议被发送回客户端
IDE 显示建议。点击“Tab”键接受建议
...该过程重复进行，以得出下一个建议。
这种“tab模型”必须尽可能快，数据传输量也尽可能低。发送上下文信息的数量和建议的质量之间总是存在权衡：Cursor 发送的相关上下文信息越多，建议就越好。然而，发送大量上下文信息会降低建议的显示速度，因此，如何正确处理这个问题对 Cursor 的工程师来说是一个挑战。

Cursor的聊天功能如何在服务器上不存储代码的情况下运行
Cursor 支持聊天模式，可用于询问代码库、与代码库“聊天”，或要求 Cursor 执行一些操作，例如启动代理进行重构、添加功能、修改方法等。后端不存储任何源代码，但所有 LLM 操作都在那里完成。它通过代码库索引来管理这些操作。其工作原理如下：

在聊天模式下提问： 我们以代码库中定义在 server.js 中的 createTodo() 方法为例进行提问。 为了更复杂一些，我在 index.html 中以内联方式定义了一个类似的方法，名为 addTodo()。让我们看看 Cursor 如何处理这个问题！




该提示词被发送到 Cursor 服务器，在那里它对其进行解释，并决定需要执行代码库搜索：






搜索开始：






搜索使用代码库索引完成 。代码库索引是先前创建的embedding(嵌入)。它尝试使用向量搜索来找到与上下文最匹配的embedding。在本例中，向量搜索返回了两个非常接近的结果：在 server.js 和 index.html 中。

从客户端请求代码： 服务器不存储任何源代码，但现在从 server.js 和 index.html 请求源代码，因此它可以分析两者并确定哪个是相关的：




最后，经过向量搜索并向客户端请求相关源代码后，服务器就获得了回答问题所需的上下文：






Cursor 在后台做了一些事情来使这些类型的搜索能够发挥作用。

使用代码块对代码进行语义索引（Semantic indexing code with code chunks）
为了像上述情况一样使用embeddings进行向量搜索，Cursor 首先需要将代码分解成更小的块，创建embeddings，并将这些embeddings存储在服务器上。具体操作如下：






创建代码块。Cursor 将文件内容切片并切分成更小的部分。每个部分稍后都会被创建成一个embedding 。
创建embedding时无需存储文件名或代码。Cursor 甚至不想将文件名存储在服务器上，因为它可能被视为机密信息。相反，它会将经过混淆的文件名和加密的代码块发送到服务器。服务器解密代码，使用 OpenAI 的嵌入模型 （或他们自己的模型）创建嵌入，并将嵌入存储在他们的向量数据库 Turbopuffer 中。
创建embeddings的计算成本很高，这也是 Cursor 后端使用云端 GPU 进行操作的原因之一。对于中型代码库，索引通常只需不到一分钟；而对于大型代码库，则可能需要几分钟甚至更长时间。您可以在 Cursor 内部的“Cursor 设置”→“索引”中查看索引状态：






使用 Merkle 树保持索引最新（Keeping the index up-to-date using Merkle trees）
当您使用 Cursor 或其他 IDE 编辑代码库时，Cursor 的服务器索引可能会过期。一个比较简单的解决方案是每隔几分钟运行一次重新索引操作。然而，由于索引的计算成本高昂，并且会通过传输加密的代码块来占用带宽，因此这种方法并不理想。为此，Cursor 巧妙地利用了 Merkle 树和高延迟同步引擎（同步引擎每 3 分钟运行一次），以保持服务器索引的更新。 Merkle 树是一棵树，其每个叶子节点都是底层文件的加密哈希值（例如，main.js 文件的哈希值）。每个节点都是其子节点哈希值的组合。一个包含四个文件的简单项目的 Merkle 树如下所示：




基于代码库中的代码的 Merkle 树

Merkle 树的工作原理：

每个文件都会根据其内容获得一个哈希值。树的叶子就是文件。
每个文件夹都会根据其子文件夹的哈希值获得一个哈希值。
Cursor 使用的 Merkle 树与此非常相似，只是 Cursor 使用经过混淆的文件名。Cursor 客户端会根据本地文件创建 Merkle 树，服务器也会根据已完成索引的文件创建 Merkle 树。这意味着客户端和服务器都会存储各自的 Merkle 树。

Cursor 每 3 分钟会进行一次索引同步。 为了确定哪些文件需要重新索引，它会比较两棵 Merkle 树：一棵位于客户端，作为真实数据的来源；另一棵位于服务器，作为索引的状态。我们以客户端“index.html”的更改为例：






Client and server-side Merkle trees out of sync. Cursor uses obfuscated filenames, actual filenames above are for simplicity 客户端和服务器端 Merkle 树不同步。Cursor 使用模糊文件名，以上实际文件名仅供参考

树形遍历用于定位需要重新索引的位置。 我们开发人员很少实现树形遍历，但在本例中，Cursor 工程师不得不这么做。Merkle 树使树形遍历更加高效，因为从根节点开始，很容易判断哈希值是否匹配。如果哈希值存在差异，也很容易找到需要同步的文件。同样重要的是，Merkle 树将同步操作最小化，仅同步已更改的文件。

这种 Merkle 树结构与 Cursor 的实际使用非常契合。例如，一天结束时关闭电脑，然后从 git 仓库获取更新，开启新的一天，这很常见。在团队中，很多文件在第二天早上发生更改也很常见。借助这种 Merkle 树，Cursor 可以尽可能少地重新索引，从而节省客户端的时间，并尽可能高效地利用服务器端的计算资源。

Secure indexing 安全索引
尽管 Cursor 不会在服务器端存储代码，但代码库中仍然有一些敏感数据，即使加密后也不宜发送。敏感数据包括机密信息、API 密钥和密码。

使用 .gitignore 和 .cursorignore 是确保索引安全的最佳方法。 机密信息、API 密钥、密码和其他敏感信息不应上传到源代码管理，通常存储为本地变量或添加到 .gitgnore 的本地环境文件（.env 文件）。Cursor 尊重 .gitignore 文件，不会索引其中列出的文件，也不会将这些文件的内容发送到服务器。此外，它还提供了一个 .cursorignore 文件，用于添加 Cursor 需要忽略的文件。

在上传块进行索引之前，Cursor 还会扫描代码块以查找可能的秘密或敏感数据，并且不会发送它们。

索引非常大的代码库（Indexing very large codebases）
对于海量代码库（通常是包含数千万行代码的单一仓库），索引整个代码库极其耗时，会占用 Cursor 的大量计算资源，而且通常没有必要。此时使用 .cursorignore 文件是明智的做法。文档提供了更多指导 。